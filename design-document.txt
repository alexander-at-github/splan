*** PDDL 3.1 requirements to implement:
  Core:
    * strips
    * action-costs: Only parsing. No consideration in data structures or
      planner (for now).
    * negative preconditions
    * conditional effects
    * typing: that makes grounding smaller.
  Nice to have:
    * adl
  Explicitly not part of this project:
    * derived predicates

*** Grounder:
  * Operation breakdown:
    Grounder module has a ground-action pool. Each step in planning it grounds
    all applicable actions with all objects and adds newly generated grounded
    actions to pool. We believe that a fix point of ground actions is reached
    and the planner only reuses actions from this pool thereafter.
  * A grounding is a binding from struct variable to struct constant for a
    specific action.
  * Make sure the grounder checks also types, which where specified in the 
    predicates definition.


*** Types:
  * Every type must be declared before it is used. The only exception to
    this rule is the type 'object', which we call the root of the type
    system.
  * Types form a hierarchy. Every type is child of another type. The
    only exception to this rule is the root type. It does not have a
    parent. If no parent type is given explicitly, it will be a direct
    child of the root.
  * Every variable or constant has a type. If there is no type given
    explicitly in the PDDL file, it will be given the root type.
  * There is a module for managing types.

*** Predicates:
  * Should there be a module for predicates similar to the types module?

*** Effects with conditional effects in PDDL:

    effect----|-and-------|-literal
              |           |-forall------effect
              |           |-when------|-and---------literal
              |                       |-literal
              |-literal
              |-forall------effect
              |-when------|-and---------literal
                          |-literal


OPEN QUESTIONS
* action list is a very primitive single linked list. Concatenation takes
  O(n) where n is the length of the first list. Should we imporve the list
  implementation?

TODO:
* Turn off assertions for time measurments.
* Put return value and function name on separate lines.
* Refactor struct state such that it consists of an array of pointers to
  fluents.
